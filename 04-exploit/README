/**
  * Mihai-Eugen Barbu [2020-2021]
  * 325CA
  */

==== IOCLA - Tema 4 - Exploit ELFs ====

>> Utilitare folosite : ghidra, gdb

<> 1. Analiza binarului

    --> folosind ghidra se identifica ca vulnerabilitatea apare in functia de la adresa <0x080492de>

           -- prin intermediul functiei read() se pot citi de la stdin 0x13b = 315 bytes
              intr-un buffer avand dimensiunea de 303 bytes -> buffer overflow

<> 2. Spargerea binarului

    --> folosind ghidra se observa ca in interiorul functiei vulnerabile se apeleaza functia 
          de la adresa <*param_1> - primul parametru al functiei

             > trebuie suprascrisa valoarea lui *param_1 <-> adresa indicata in ebp + 8
             > folosind gdb se identifica adresa de inceput a bufferului ca fiind ebp - 0x12f
                               ^ se obtine un offset de 8 + 0x12f = 0x137 
                                 intre adresa de inceput a bufferului si primul parametru

             > se identifica, folosind ghidra, adresa functiei print_flag <0x08049291> 
                                                  - valoare care va suprascrie valoarea lui *param_1;
                  # se tine cont de format - little-endian

      >> se obtine flag-ul NICE_FLAG{1e3370aa651c9314baacdda07b6c109e}

<> 3. Spargerea binarului v2

    ~ Se observa ca din main() sunt apelate - succesiv - mai multe functii vulnerabile astfel:

         (1) <0x080492de> -> se pot citi 0xf2 = 242 bytes intr-un buffer de dimensiune 174 bytes
         (2) <0x0804930b> -> se pot citi 0x19f = 415 bytes intr-un buffer de dimensiune 316 bytes
         (3) <0x08049338> -> sse pot citi 0x10c = 268 bytes intr-un buffer de dimensiune 44 bytes

    ~ Pentru fiecare functie se determina adresa de inceput a bufferului:

         (1) : ebp - 0x132 = ebp - 306
         (2) : ebp - 0x200 = ebp - 512
         (3) : ebp - 0xfc = ebp - 252

    ~ Mai mult, se observa ca trebuie suprascrise urmatoarele variabile:
                              ^ folosind gdb se identifica unde se afla

         (1) : local_88 pentru a satisface egalitatea cu 0xcf7654f4
                                 ^ se afla la <ebp - 0x84> = <ebp - 132>

             >> se genereaza un payload_1 = (306 - 132) * "A" + "\xf4\x54\x76\xcf" + (242 - (306 - 132 + 4)) * "Z"
              

         (2) : local_c8 - egalitate cu 0x2b63368b
                          ^ se afla la <ebp - 0xc4> = <ebp - 196>

            >> se genereaza un payload_2 = (512 - 196) * "A" + "\x8b\x36\x63\x2b" + (415 - (512 - 196 + 4)) * "Z"

         (3) : local_d4 - egalitate cu 0x9b74cb10
                          ^ se afla la <ebp - 0xd0> = <ebp - 208>

              > se observa apelarea functiei de la adresa <*param2>
                                                   ^ conform gdb, al doilea parametru se afla la ebp + 0xc = ebp + 12
                                                   ^ se va suprascrie cu adresa functiei print_flag

            >> se genereaza un payload_3 = (252 - 208) * "A" + "\x10\xcb\x74\x9b" 
                                           + (12 + 252 - (252 - 208 + 4)) * "B" + "\x91\x92\x04\x08"
                            -- <0x08049291> - adresa functiei print_flag

       --> se va genera payload-ul final ca fiind payload_1 + payload_2 + payload_3

          >> se obtine flag-ul NAUGHTY_FLAG{a8e03a438a2039f4377b6263011dafe1}

